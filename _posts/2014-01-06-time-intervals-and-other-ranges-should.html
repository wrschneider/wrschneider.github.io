---
layout: post
title: Time intervals and other ranges should be half-open
date: '2014-01-06T22:15:00.001-05:00'
author: Bill Schneider
tags:
- programming
modified_time: '2014-01-06T22:15:23.647-05:00'
blogger_id: tag:blogger.com,1999:blog-9159309.post-1371638861946633498
blogger_orig_url: http://wrschneider.blogspot.com/2014/01/time-intervals-and-other-ranges-should.html
---

It is a good practice to treat time intervals as half-open inequalities: start &lt;= x &lt; end.  Note the asymmetry. &nbsp;This is&nbsp;<a href="http://joda-time.sourceforge.net/key_interval.html">how the Joda-Time API implements time intervals</a>, and also how the SQL "overlaps" keyword works. &nbsp;Also note that SQL "between" does <i>not</i>&nbsp;behave the same way.<br /><br />The main reason this is important is to allow adjacent time intervals like 10:00-11:00 and 11:00-12:00, such that the instant of 11:00:00 falls in the second interval, but not the first.<br /><br />It is a mistake to try turning the intervals into 10:00-10:59, etc.  An instant like 10:59:01 would fall through the cracks between intervals, and end minus start would be 59 minutes rather than an hour.<br /><br />With date or timestamp ranges, the same logic applies. &nbsp;But there's a key difference: while end-users tend to think of time ranges intuitively as half-open, they often tend to think of date ranges as closed. &nbsp;That is, users expect 10:00-11:00 and 11:00-12:00 to be adjacent and non-overlapping even though 11:00 is the end of one range and the start of another. &nbsp;For dates, though, users tend to think of ranges like Jan 1-Dec 31 inclusive of the last day of the month/year.<br /><br />So what to do? &nbsp;There are two workable solutions. &nbsp;One is to apply the same half-open inequality as before, adding a day to the user-specified end date. &nbsp;So you would have something like 1/1/2013 &lt;= x &lt; 1/1/2014. Another is to truncate the input under test: 1/1/2013 &lt;= trunc(x) &lt;= 12/31/2013. &nbsp;This gives the same results, because any instant up to and excluding 1/1/2014 will be included in the range. &nbsp;The first approach is better because you don't have to remember to strip the time portion off of x before testing.<br /><br />A wrong answer is to do something like 1/1/2013@midnight &lt;= x &lt;= 12/31/2013@23:59:59. &nbsp;This assumes you know the exact precision of x, and there's a risk of a moment of time falling through the cracks again. &nbsp;It's also just icky.<br /><br />Integer ranges where the input under test is a decimal behave like dates and times, with the same options. Currency is a good example: you can use half-open ranges such that $100-200 and $200-300 are adjacent and non-overlapping and $200.00 falls in only the second range. &nbsp;You could also have the user specify closed ranges like $100-199 and $200-299 and do the same thing with floor(x) or start &lt;= x &lt;= end&nbsp;+ 1. &nbsp;What you <i>can't </i>do is let $199.01 fall between the two adjacent intervals or let $200.00 match both ranges.<br /><br />Incidentally, it seems like even when we're dealing with pure integer ranges, the common practice in Java is to use half-open intervals for things like substrings, and Python does the same for array slicing. &nbsp;This seems to be the best practice for programming in general, for readability and minimizing chance of mistakes (see&nbsp;<a href="http://stackoverflow.com/questions/8441749/representing-intervals-or-ranges">http://stackoverflow.com/questions/8441749/representing-intervals-or-ranges</a>).