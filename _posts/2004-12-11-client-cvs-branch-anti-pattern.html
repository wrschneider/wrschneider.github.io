---
layout: post
title: '"Client CVS Branch" anti-pattern'
date: '2004-12-11T12:07:00.000-05:00'
author: Bill Schneider
tags: 
modified_time: '2004-12-11T12:11:31.320-05:00'
blogger_id: tag:blogger.com,1999:blog-9159309.post-110278493594363125
blogger_orig_url: http://wrschneider.blogspot.com/2004/12/client-cvs-branch-anti-pattern.html
---

  <p class="MsoNormal">Scenario: Your team developed a custom application for Client A.<span style="">  </span>The application is generally useful, so it gets re-sold to Client B.<span style="">  </span>Client B wants some customizations, which are at first superficial (CSS, images, etc.), and the client expects a quick turnaround.<span style="">  </span>So, you need a way to store Client B’s new version of the app in source control somehow, and you take the first approach that comes to mind: you create a branch of the original, and make the customizations for Client B on the new branch.<span style="">
<br /></span></p> (Without loss of generality, I’m assuming you’re using CVS; Subversion and Perforce have different branch/merge models but they basically boil down to the same thing.<span style="">  </span>But if you’re using PVCS or VSS, or worse, not using source control at all, you have bigger problems which I’ll save for some other time.)<span style=""> </span> <p class="MsoNormal">At first, this works pretty well.<span style="">  </span>But over time, you sell the same app to more clients, and they are each asking for more substantial new feature development.<span style="">  </span>The strategy starts to break down, causing a whole series of problems:</p> <p class="MsoNormal" style="margin-left: 0.5in; text-indent: -0.25in;"><!--[if !supportLists]--><!--[endif]-->- Bug fixes have to be explicitly merged into each client’s branch individually. </p>   <p class="MsoNormal" style="margin-left: 0.5in; text-indent: -0.25in;"><!--[if !supportLists]--><span style="">-<span style="">         </span></span><!--[endif]-->Since the code in each client branch diverges over time as different things are added or changed in one or the other, merging bug fixes results in more manual conflict resolution.<span style="">  </span>(The same thing goes for new features.)<span style="">   </span>This also makes for more re-testing of the same thing. </p>   <p class="MsoNormal" style="margin-left: 0.5in; text-indent: -0.25in;"><!--[if !supportLists]--><span style="">-<span style="">         </span></span><!--[endif]-->There is a potential for wheel reinvention.<span style="">  </span>If you develop a new feature for Client C, and Client D asks for a new feature that is “close but not quite” the same as Client C’s, it may be developed independently twice rather than building it once in a way that accommodates both sets of requirements.<span style="">  </span></p>   <p class="MsoNormal" style="margin-left: 0.5in; text-indent: -0.25in;"><!--[if !supportLists]--><span style="">-<span style="">         </span></span><!--[endif]-->You fail to realize potential economies of scale of in support or maintenance that you should get from having a single solution, since each client effectively has their own one-off version.</p> <p class="MsoNormal">The problem stems from the lack of a well-defined “trunk” in source control that provides the common baseline functionality.<span style="">  </span>Instead, each client’s version was branching off of <i style="">another client’s </i>branch (Client A’s) rather than from a common trunk.<span style="">   </span>So there was no way to nail down which part of the code stays constant for all clients.<span style="">  </span></p>     <p class="MsoNormal">Here's a few ways to solve this problem:<span style=""> </span></p>   <p class="MsoNormal" style="margin-left: 0.5in; text-indent: -0.25in;"><!--[if !supportLists]--><span style="">-<span style="">         </span></span><!--[endif]-->Have each client’s version be a branch from a common trunk, and have the discipline to make as much functionality in the trunk configurable at deployment/runtime as possible (the later the binding, the better).<span style="">  </span>That way, you increase the percentage of code that all clients have in common, and establish a common baseline version that multiple clients share.<span style="">  </span>Also, there will then be a well-defined process for upgrading a client’s branch to a new version of the baseline “core” code, and many fewer post-merge conflicts to resolve manually.</p> <p class="MsoNormal" style="margin-left: 0.5in; text-indent: -0.25in;"><!--[if !supportLists]--><span style="">-<span style="">         </span></span><!--[endif]-->Most teams won’t actually have the discipline to consistently put in the extra effort to make new features configurable.<span style="">  </span>So you can take this a step further: give each client is own separate repository that contains <i style="">only </i>the customizations for that client, then apply those customizations as a patch against the common baseline version.<span style="">  </span>This will force you to think about whether any given code should be common and shared across all clients or whether it is a customization.<span style="">
<br /></span></p> <p class="MsoNormal" style="margin-left: 0.5in; text-indent: -0.25in;"><!--[if !supportLists]--><span style="">-<span style="">         </span></span><!--[endif]-->There is also a management aspect to solving this problem: make sure someone is accountable for the entire solution as deployed for <i style="">all</i> clients, not just each individual client’s project.<span style="">  </span>When you’re only accountable for your own client, you’ll inevitably take the path of least resistance to keep your own client happy and not see the bigger picture of delivering for all clients more effectively (this is actually <i style="">rational</i> behavior according to game theory).</p>