---
layout: post
title: JSF + JPA without EJB or Spring
date: '2011-09-07T21:37:00.001-04:00'
author: Bill Schneider
tags: 
modified_time: '2011-09-07T21:37:28.365-04:00'
blogger_id: tag:blogger.com,1999:blog-9159309.post-5652208609672838476
blogger_orig_url: http://wrschneider.blogspot.com/2011/09/jsf-jpa-without-ejb-or-spring.html
---

I've had success using JSF 2.0 with JPA on Glassfish 3.0.1, without using Spring or EJB for managing middle-tier services or DAOs.  (I actually do like Spring - the goal in this case was to minimize dependencies, moving parts and learning curve, rather than to avoid any particular technology.)<br /><br />A similar approach was detailed here:<br /><a href="http://www.swview.org/blog/best-way-use-jpa-web-tier">http://www.swview.org/blog/best-way-use-jpa-web-tier</a><br /><br />&nbsp;Using only the JSF @ManagedBean and @ManagedProperty annotations, along with the JPA @PersistenceContext, you can refactor business services or DAOs into other JSF managed beans that are injected into the one exposed directly to the UI.  What this looks like in practice:<br /><br />&nbsp;orders.xhtml: <br /><pre class="brush:xml"><h:datatable value="#{orderBean.orders}" var="order"> <br /></h:datatable></pre><br />OrderBean.java: <br /><pre class="brush:java">@ManagedBean<br />public class OrderBean {<br />  @ManagedProperty(value="#{orderDao}")<br />  private OrderDao orderDao;<br />  private List<order> orders;<br />   <br />  @PostConstruct<br />  public void init() { <br />    this.orders = orderDao.getOrders();<br />  } <br />  public List<order> getOrders() { <br />    return orders;<br />  }<br />}<br /></order></order></pre><br />OrderDao.java: <br /><pre class="brush:java">@ManagedBean<br />@ApplicationScoped<br />public class OrderDao {<br />   @PersistenceContext(...)<br />   private EntityManager em;<br />   <br />   public List&lt;Order&gt; getOrders() { <br />     return em.findAll(Order.class);<br />   }<br />}<br /></pre>In this example, the DAO (OrderDao) is just another JSF managed bean, but not actually referenced directly from a page, only from another managed bean.    This approach lets you isolate the logic tied to EntityManagers from the rest of your "normal" JSF managed beans, and makes it (marginally) easier to unit-test your managed beans because you can mock the DAO at a higher level instead of mocking the entity manager.<br /><br />&nbsp;This does NOT buy you declarative transactions or any of the other good stuff you get with Spring or EJB.  (You can inject a UserTransaction with @Resource, and call it explicitly, though.)  So it works best for simple apps with mostly read operations and basic single-object CRUD transactions.<br /><br />&nbsp;Also, with Java EE 6 CDI, all this may become moot because @Named and @Inject annotations effectively blur the line between all the different managed bean flavors (EJB, JSF, Spring/POJO), although I haven't found a good way to replace JSF @ViewScoped without buying into Seam. 