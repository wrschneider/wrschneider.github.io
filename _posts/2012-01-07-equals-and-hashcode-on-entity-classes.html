---
layout: post
title: 'equals and hashCode on @Entity classes: just say no'
date: '2012-01-07T21:23:00.001-05:00'
author: Bill Schneider
tags:
- java
- jpa
modified_time: '2012-01-13T21:52:39.924-05:00'
blogger_id: tag:blogger.com,1999:blog-9159309.post-7767464144763430126
blogger_orig_url: http://wrschneider.blogspot.com/2012/01/equals-and-hashcode-on-entity-classes.html
---

I've come to the conclusion that you should avoid defining equals and hashCode on JPA @Entity objects unless you have a really good reason to.<br /><br />Doing it right is non-trivial, with all the gotchas and caveats.&nbsp; First, the logistics:<br /><ul><li>You can't use the primary key because multiple unsaved objects all have a null PK and would be "equal".&nbsp;&nbsp;</li><li>Using the PK with object identity as fallback means an object won't be equal to itself before and after being persisted, and hash-based collections won't work properly if the hash code changes during the collection's lifespan.</li><li>A unique business key could work, if that's an option - but you have to remember to maintain the equals and hashCode method if those properties or relations change. &nbsp;Also if that key isn't immutable, you have a similar problem as with PK + fallback above.</li><li>Creating a UUID in the constructor just to make equals and hashcode work is... yucky.</li><li>Often these methods are insufficiently covered by unit tests.</li></ul>Second: there's the deeper question of what should "equals" mean in the context of a mutable business entity? &nbsp;What comparison makes sense is often context-dependent. &nbsp;Sometimes you might want to compare based on primary key, other times you might want to compare on some other property.<br /><br />So what's the worst thing that happens if you just don't do anything, and take the default based on object identity? <br /><br />Usually, you won't even miss these methods. &nbsp;The default implementation will work fine unless you're trying to compare objects loaded in two&nbsp;<i>different</i>&nbsp;persistence sessions/transactions,with either equals() or contains(). &nbsp;&nbsp;I've found this is the exception case - much of my collection manipulation in practice is manipulating objects all loaded in the same session to hand off to the view layer, so HashSet recognizes duplicates and contains() works just fine. &nbsp;And I almost never use an entity as a key in a hashmap.<br /><br />The price you pay is more verbosity when you do need to compare objects between a session-scoped cache and the current request. &nbsp;You have to remember that obj1.equals(obj2) doesn't work, and needs to be replaced with obj1.getId().equals(obj2.getId()). &nbsp;Contains is a bit more verbose, and a utility method like containsById(collection, obj) might be helpful. &nbsp;Some people will say it's confusing that equals doesn't "just work" but I find it less confusing to be explicit about what you're comparing on - and less confusing than a broken or unmaintained equals() method.<br /><br />Finally, if this were C#, we wouldn't even have this discussion. &nbsp;With closures and LINQ extension methods we would just say "collection.Where(obj =&gt; obj.id = foo.id)" and be done with it!<br /><br />Related links:<br />http://community.jboss.org/wiki/EqualsAndHashCode<br /><br />http://onjava.com/pub/a/onjava/2006/09/13/dont-let-hibernate-steal-your-identity.html?page=3<br /><br />http://stackoverflow.com/questions/1929445/to-equals-and-hashcode-or-not-on-entity-classes-that-is-the-question<br /><br />http://stackoverflow.com/questions/1638723/equals-and-hashcode-in-hibernate<br /><br /><a href="https://forum.hibernate.org/viewtopic.php?t=928172">https://forum.hibernate.org/viewtopic.php?t=928172</a><br /><br /><a href="http://www.ibm.com/developerworks/java/library/j-jtp05273/index.html">http://www.ibm.com/developerworks/java/library/j-jtp05273/index.html</a>: "For mutable objects, the answer is not always so clear. Should equals() and hashCode() be based on the object's identity (like the default implementation) or the object's state (like Integer and String)? There's no easy answer -- it depends on the intended use of the class...&nbsp;It is not common practice to use a mutable object like a List as a key in a HashMap."<br /><div><br />http://burtbeckwith.com/blog/?p=53</div>